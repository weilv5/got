package com.jsict.biz.service.impl;

import com.jsict.biz.dao.DepartmentDao;
import com.jsict.biz.model.Department;
import com.jsict.biz.model.Role;
import com.jsict.biz.model.User;
import com.jsict.biz.service.UserService;
import com.jsict.framework.core.controller.RestControllerException;
import com.jsict.framework.core.service.impl.GeneriServiceImpl;
import com.jsict.framework.utils.Encodes;
import com.jsict.framework.utils.SysConfig;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/**
 * Auto-Generated by UDP Generator
 */
@Service("userService")
public class UserServiceImpl extends GeneriServiceImpl<User, String> implements UserService {

    @Autowired
    private DepartmentDao departmentDao;

    @Autowired
    private SysConfig sysConfig;

    /**
     * 添加userId唯一性校验
     *
     * @param entity  实体
     * @return
     */
    @Override
    @Transactional
    public User save(User entity) {
        User query = new User();
        query.setUserId(entity.getUserId());
        User user = singleResult(query);
        if(user!=null)
            throw new RestControllerException("用户名已经存在");
        return super.save(entity);
    }

    /**
     * @param id  主键
     * @return
     */
    @Override
    @Transactional(readOnly = true)
    public User get(String id){
        User user = super.get(id);
        if(StringUtils.isNotBlank(user.getDeptId())){
            Department department = departmentDao.getById(user.getDeptId());
            user.setDepartment(department);
        }
        return user;
    }

    @Override
    @Transactional
    public User changePassword(String id, String oldPassword, String newPassword) {
        User user = get(id);
        if(Encodes.encodeMD5(oldPassword).equals(user.getPassword())){
            user.setPassword(Encodes.encodeMD5(newPassword));
            user.setLastChangePwdTime(user.getUpdatedDate());
            return update(user);
        }else
            throw new SecurityException("密码错误");
    }

    @Override
    @Transactional
    public String doErrorPassword(String userId, Boolean increase) {
        User query = new User();
        query.setUserId(userId);
        User user = singleResultWithoutDic(query);
        if(null != user){
            Integer errorTimes = user.getPasswordErrorTimes();
            Date lastErrorTime = user.getLastPasswordErrorTime();
            Date now = new Date();
            if(null == errorTimes)
                errorTimes = 0;
            if(null == lastErrorTime)
                lastErrorTime = now;
            long interval = (now.getTime()/60000) - (lastErrorTime.getTime()/60000);
            Integer maxErrorTimes = sysConfig.getConfig().getInt("passwordMaxErrorTimes");
            Integer maxLockTime = sysConfig.getConfig().getInt("passwordMaxLockedTime");
            if(interval > maxLockTime)
                errorTimes = 0;
            if(errorTimes >= maxErrorTimes)
                return "对不起，因为您输入的密码已经多次错误，该账号将被锁定" + maxLockTime + "分钟。";
            if(increase){
                errorTimes++;
                user.setPasswordErrorTimes(errorTimes);
                user.setLastPasswordErrorTime(now);
                update(user);
            }
        }
        return null;
    }

    @Override
    @Transactional
    public void clearUserLock(String id) {
        User user = get(id);
        user.setLastPasswordErrorTime(null);
        user.setPasswordErrorTimes(0);
        update(user);
    }

    @Override
    @Transactional
    public User initPassword(String id) {
        User user = get(id);
        String password = sysConfig.getConfig().getString("defaultPassword");
        user.setPassword(Encodes.encodeMD5(password));
        return update(user);
    }

    @Transactional
    @Override
    public void enable(String id) {
        troggleEnable(id, 1);
    }

    @Transactional
    @Override
    public void disable(String id) {
        troggleEnable(id, 0);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<User> findByRole(Role role, Pageable pageable) {
        Map<String, Object> params = new HashMap<>();
        params.put("role", role);
        params.put("delFlag", 0);
        return genericDao.page("selectUserByRole", params, pageable);
    }

    private void troggleEnable(String id, Integer enable){
        User user = get(id);
        user.setEnable(enable);
        genericDao.update(user);
    }
}
